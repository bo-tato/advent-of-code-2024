(in-package :advent-of-code-2024)

(defun move-robot (map point direction)
  (unless (char= (@ map point) #\#)
    (let ((neighbor (move point direction)))
      (when (char= (@ map neighbor) #\O)
        (move-robot map neighbor direction))
      (if (char= (@ map neighbor) #\.)
          (progn (setf (@ map neighbor) (@ map point))
                 (setf (@ map point) #\.)
                 neighbor)
          point))))

(defun part2-map (map)
  (loop with new-map = (dict)
        for (row . col) being the hash-keys of map using (hash-value char)
        for (new-char1 new-char2) = (ecase char
                                      (#\# '(#\# #\#))
                                      (#\O '(#\[ #\]))
                                      (#\. '(#\. #\.))
                                      (#\@ '(#\@ #\.)))
        do (setf (@ new-map (cons row (* 2 col))) new-char1
                 (@ new-map (cons row (1+ (* 2 col)))) new-char2)
        finally (return new-map)))

(defun part2-can-move-p (map point direction)
  (if (or (eq direction :up)
            (eq direction :down))
    (ecase (@ map point)
      (#\. t)
      (#\@ (part2-can-move-p map (move point direction) direction))
      (#\[ (and (part2-can-move-p map (move point direction) direction)
                (part2-can-move-p map (col+ (move point direction)) direction)))
      (#\] (and (part2-can-move-p map (move point direction) direction)
                (part2-can-move-p map (col- (move point direction)) direction)))
      (#\# nil))
    t))

(defun part2-move-robot (map point direction)
  (unless (char= (@ map point) #\#)
    (let ((neighbor (move point direction)))
      (when (char/= (@ map neighbor) #\.)
        (ecase direction
          ((:left :right) (part2-move-robot map neighbor direction))
          ((:up :down) (part2-move-robot map
                                         (move neighbor (ecase (@ map neighbor)
                                                          (#\[ :right)
                                                          (#\] :left)))
                                         direction)
           (part2-move-robot map neighbor direction))))
      (if (char= (@ map neighbor) #\.)
          (progn (setf (@ map neighbor) (@ map point))
                 (setf (@ map point) #\.)
                 neighbor)
          point))))

(destructuring-bind (grid moves)
    (str:split #?"\n\n" (read-file-into-string "input.txt"))
  (loop ;; with map = (parse-map grid)
        with map = (part2-map (parse-map grid))
        for robot = (@ (flip-hash-table map) #\@)
        ;; then (move-robot map robot direction)
          then (if (part2-can-move-p map robot direction)
                   (part2-move-robot map robot direction)
                   robot)
        for move across (remove #\Newline moves)
        for direction = (parse-direction move)
        finally
           (return
             (loop for ((box-row . box-col) . _)
                   ;; eqls #\O for part1
                     in (remove-if-not (eqls #\[) (hash-table-alist map) :key #'cdr)
                   sum (* 100 box-row)
                   sum box-col))))
